//******************************************************************************
// Copyright (c) 2018, The Regents of the University of California (Regents).
// All Rights Reserved. See LICENSE for license details.
//------------------------------------------------------------------------------
#include "edge_wrapper.h"
#include "report.h"
#include <string.h>
#include "params.h"
#include <map>
#include<stdio.h>
#include<math.h>
#include<stdlib.h>
#include<time.h>

#include<errno.h>

/* Really all of this file should be autogenerated, that will happen
   eventually. */
#define OCALL_WRITE_BUCKETS 0
#define OCALL_PRINT_BUFFER 1
#define OCALL_PRINT_VALUE 2
#define OCALL_COPY_REPORT 3
#define OCALL_GET_STRING 4
#define OCALL_GET_TESTING_PARAMS 5
#define OCALL_READ_FROM_FILE 7
#define OCALL_GET_CONTENT_FROM_UTM 8
#define OCALL_GET_CONTENT_FROM_EPM 9
#define OCALL_READ_BUCKETS 10

#define OCALL_OPAM_READ_BUCKETS_MD 13
#define OCALL_OPAM_READ_BUCKETS_D 15
#define OCALL_OPAM_WRITE_BUCKETS 12
#define OCALL_OPAM_WRITE_BUCKETS_MD 14
#define OCALL_OPAM_WRITE_BUCKETS_D 16

#define OCALL_STORE_CONTENT_TO_UTM_ENC_PFH 18
#define OCALL_GET_CONTENT_FROM_UTM_ENC_PFH 17

#define OCALL_RORAM_READ_BUCKET_METADATA 19
#define OCALL_RORAM_READ_BLOCK 20
#define OCALL_RORAM_READ_BUCKET 21
#define OCALL_RORAM_WRITE_BUCKET_METADATA 22
#define OCALL_RORAM_WRITE_BLOCK 23
#define OCALL_RORAM_WRITE_BUCKET 24
#define OCALL_EXIT 11
#define OCALL_READ_NUM_FROM_FILE 25
#define OCALL_CALC_LOG 26
#define OCALL_CALC_EXP 28
#define OCALL_CALC_POW 29
#define OCALL_RAND 30
#define OCALL_SRAND 31
#define OCALL_SQRT 32
#define OCALL_TANH 33
#define OCALL_PRINT_DOUBLE 27

#define FULL_TRACE 34

#define OCALL_PRINT_COUNTERS 6
typedef std::map<uintptr_t, pages_at> pmap;
pmap pages_store;
size_t args_len;


typedef std::map<uintptr_t, pages> pmap2;
pmap2 pages_store2;


char f='n';
sat_struct sat_data;

void display_page_contents_arr(char *a);

//------------------------------------------------------------------------------
int edge_init(Keystone* enclave){
  sat_data.is_open = 0;

  enclave->registerOcallDispatch(incoming_call_dispatch);
  register_call(FULL_TRACE, full_trace);


  register_call(OCALL_WRITE_BUCKETS, write_buckets);
  register_call(OCALL_PRINT_BUFFER, print_buffer_wrapper);
  register_call(OCALL_PRINT_VALUE, print_value_wrapper);
  register_call(OCALL_PRINT_DOUBLE, print_double_wrapper);
  register_call(OCALL_COPY_REPORT, copy_report_wrapper);
  register_call(OCALL_GET_STRING, get_host_string_wrapper);
  register_call(OCALL_GET_TESTING_PARAMS, get_testing_params);
  register_call(OCALL_GET_CONTENT_FROM_UTM, get_host_content_from_utm_wrapper);
  register_call(OCALL_GET_CONTENT_FROM_EPM, get_enclave_content_from_epm_wrapper);
  register_call(OCALL_READ_BUCKETS, read_bucket);
  register_call(OCALL_READ_FROM_FILE, read_from_file_wrapper);
  register_call(OCALL_READ_NUM_FROM_FILE, read_num);
  register_call(OCALL_CALC_LOG, calc_log);
  register_call(OCALL_CALC_EXP, calc_exp);
  register_call(OCALL_CALC_POW, calc_pow);
  register_call(OCALL_RAND, calc_rand);
  register_call(OCALL_SRAND, calc_srand);
  register_call(OCALL_SQRT, calc_sqrt);
  register_call(OCALL_TANH, calc_tanh);

  register_call(OCALL_OPAM_READ_BUCKETS_MD, opam_read_bucket_md);
  register_call(OCALL_OPAM_READ_BUCKETS_D, opam_read_bucket_d);
  register_call(OCALL_OPAM_WRITE_BUCKETS, opam_write_buckets);
  register_call(OCALL_OPAM_WRITE_BUCKETS_MD, opam_write_buckets_md);
  register_call(OCALL_OPAM_WRITE_BUCKETS_D, opam_write_buckets_d);

  register_call(OCALL_GET_CONTENT_FROM_UTM_ENC_PFH, get_host_content_from_utm_wrapper_enc_pfh);
  register_call(OCALL_STORE_CONTENT_TO_UTM_ENC_PFH, store_content_to_utm_enc_pfh);

  register_call(OCALL_PRINT_COUNTERS, print_counters);
  register_call(OCALL_EXIT, call_exit);

  register_call(OCALL_RORAM_WRITE_BUCKET, roram_write_bucket_init);
  register_call(OCALL_RORAM_READ_BLOCK, roram_read_block);

  edge_call_init_internals((uintptr_t)enclave->getSharedBuffer(),
			   enclave->getSharedBufferSize());
}
//------------------------------------------------------------------------------
void print_counters(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;
  // add &args_len

  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  counter counters[NO_OF_COUNTERS];
  uintptr_t tree_index=   *(uintptr_t*)call_args;//0x3fffefa9b0
  Bucket_opam buc_d;
  memcpy((void*)counters, (void*) call_args   ,NO_OF_COUNTERS*sizeof(counter));

  FILE *fptr = fopen(pc_file, "a");
  if (fptr == NULL)
  {
      printf("[UTM] Could not open file in print_counters\n");
      return;
  }


  /*
  fprintf(fptr,"enclave name:%s\n", enc_name);
  fprintf(fptr,"page fault handling:%d\n", args_user.page_fault_handler);
  fprintf(fptr,"integrity-protection:%d\n", args_user.integrity_protection);
  fprintf(fptr,"confidentiality:%d\n", args_user.confidentiality);
  fprintf(fptr,"tracing:%d\n", args_user.page_addr_tracing);
  fprintf(fptr,"# of free pages:%d\n", args_user.num_free_pages);
  fprintf(fptr,"tracing file name:%s\n", trace_file);
  fprintf(fptr,"counter file name:%s\n", pc_file);

  for(int i=0;i<NO_OF_COUNTERS;i++)
  {
    if(i<=6)
      fprintf(fptr,"%s:%d\n",counters[i].name,counters[i].count);
    else  if(args_user.page_fault_handler==1 ||args_user.page_fault_handler==2 || args_user.page_fault_handler==4)
      fprintf(fptr,"%s:%d\n",counters[i].name,counters[i].count);
  }
  */

  fprintf(fptr,"%s,", enc_name);
  fprintf(fptr,"%d,", args_user.page_fault_handler);
  fprintf(fptr,"%d,", args_user.integrity_protection);
  fprintf(fptr,"%d,", args_user.confidentiality);

  for(int i=0;i<NO_OF_COUNTERS-1;i++)
  {
    fprintf(fptr,"%lu,",counters[i].count);
  }
  enc_run_wo_oram_init=counters[14].count;
  copy_waste=counters[15].count;

  fclose(fptr);
}
//------------------------------------------------------------------------------




void read_from_file_wrapper(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call,&call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  file_struct* file_data = (file_struct*)call_args;

  long block_size = file_data->block_size;
  long num_blocks = file_data->num_blocks;
  long offset = file_data->offset;

  //printf("Reading file %s\n",(char*)(file_data+1));
  //printf("Data: %d\n",block_size*num_blocks);

  FILE* fd=fopen((char*)(file_data+1),"r");
  if(fd == NULL)
  {
    printf("Error opening file %s, %s\n",(char*)(file_data+1),strerror(errno));
    return;
  }
  char* data_buf=(char*)malloc(block_size * num_blocks + sizeof(unsigned long));
  if(data_buf == NULL)
  {
    printf("Error allocating buffer\n");
    return;
  }
  if(fseek(fd,offset,SEEK_SET) == -1)
  {
    printf("Error parsing library file\n");
    return;
  }

  int bytes_read=fread(data_buf,block_size,num_blocks,fd);
  //printf("Bytes Read %d\n",bytes_read);
  uintptr_t data_section = (uintptr_t)malloc(bytes_read*block_size + sizeof(int));
  *((int*)data_section) = bytes_read;
  memcpy((void*)((int*)data_section + 1), (void*)data_buf,bytes_read * block_size);
  fclose(fd);
  //printf("Data read %s\n",data_buf);
  //printf("Bytes read %d\n",bytes_read*block_size);

  if(edge_call_setup_wrapped_ret(edge_call, (void*)data_section, bytes_read*block_size + sizeof(int)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}
//------------------------------------------------------------------------------

void read_num(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call,&call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  int already = *(int*)call_args;
  //printf("Already read: %d\n",already);
  int number;

  FILE* fd = fopen("SAT.txt","r");
  if(fd == NULL)
  {
    printf("Error opening file\n");
    exit(1);
  }
  int num;
  for(int i=0; i<= already;i++)
  {
    num = fscanf(fd,"%d ",&number);
    //printf("%d ",number);
    if(num != 1)
    {
      number = 1000000;
      break;
    }
  }
  //printf("\n");
  fclose(fd);
  if(edge_call_setup_wrapped_ret(edge_call, (void*)(&number),sizeof(int)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

//------------------------------------------------------------------------------

void calc_log(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call,&call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  double already = *(double*)call_args;
  double number = log(already);
  if(edge_call_setup_wrapped_ret(edge_call, (void*)(&number),sizeof(double)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

void calc_tanh(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call,&call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  double already = *(double*)call_args;
  double number = tanh(already);
  if(edge_call_setup_wrapped_ret(edge_call, (void*)(&number),sizeof(double)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

void calc_exp(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call,&call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  double already = *(double*)call_args;
  double number = exp(already);
  if(edge_call_setup_wrapped_ret(edge_call, (void*)(&number),sizeof(double)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

void calc_sqrt(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call,&call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  double already = *(double*)call_args;
  double number = sqrt(already);
  if(edge_call_setup_wrapped_ret(edge_call, (void*)(&number),sizeof(double)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

void calc_srand(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call,&call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  unsigned int already = *(unsigned int*)call_args;
  srand(already);
  edge_call->return_data.call_status = CALL_STATUS_OK;
  return;
}

void calc_rand(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  int number = rand();
  if(edge_call_setup_wrapped_ret(edge_call, (void*)(&number),sizeof(int)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

typedef struct pow_struct
{
	double num1;
	double num2;
}pow_struct;

void calc_pow(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  if(edge_call_args_ptr(edge_call,&call_args) != 0)
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  pow_struct* already = (pow_struct*)call_args;
  double number = pow(already->num1,already->num2);
  if(edge_call_setup_wrapped_ret(edge_call, (void*)(&number),sizeof(double)))
  {
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else
  {
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}

//------------------------------------------------------------------------------
void print_buffer_wrapper(void* buffer)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  ret_val = print_buffer((char*)call_args);
  // We are done with the data section for args, use as return region
  // TODO safety check?
  uintptr_t data_section = edge_call_data_ptr();
  memcpy((void*)data_section, &ret_val, sizeof(unsigned long));

  if( edge_call_setup_ret(edge_call, (void*) data_section, sizeof(unsigned long))){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }

  return;

}

void call_exit(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;

  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  exit(*(int*)call_args);
}
//------------------------------------------------------------------------------
void print_value_wrapper(void* buffer)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */

  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  //print_value(*(long*)call_args);
  printf("[ENCLAVE LONG LONG HEX]: %llx\n",*(long long int*)call_args);
  edge_call->return_data.call_status = CALL_STATUS_OK;
  return;
}
//------------------------------------------------------------------------------
void print_double_wrapper(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  //print_value(*(long*)call_args);
  printf("Enclave received: %lf\n",*(double*)call_args);
  edge_call->return_data.call_status = CALL_STATUS_OK;
  return;
}
//------------------------------------------------------------------------------
void copy_report_wrapper(void* buffer)
{

  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t data_section;
  unsigned long ret_val;
  //TODO check the other side of this
  if(edge_call_get_ptr_from_offset(edge_call->call_arg_offset, sizeof(report_t),
				   &data_section) != 0) {
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  copy_report((void*)data_section);
  edge_call->return_data.call_status = CALL_STATUS_OK;
  return;
}
//------------------------------------------------------------------------------
void get_host_string_wrapper(void* buffer)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  char host_str[18100];
  host_str[0]='X';
  host_str[18100-2]='X';
  host_str[18100-1]='\0';

  for(int i=1;i<=18100-3;i++)
      host_str[i]='R';

  size_t host_str_len = strlen(host_str)+1;
  // This handles wrapping the data into an edge_data_t and storing it
  // in the shared region.
  if( edge_call_setup_wrapped_ret(edge_call, (void*)host_str, host_str_len)){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }

  return;
}
//------------------------------------------------------------------------------

void get_host_content_from_utm_wrapper(void* buffer)
{

  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  uintptr_t source_page_vaddr=   *(uintptr_t*)call_args;//0x3fffefa9b0
  //char source_page[size]= {0,};
  pages p;
  //p= (pages_store2.find(source_page_vaddr))->second;
  p=p_arr[source_page_vaddr>>(12)];
  //memcpy((void*)source_page,source_page_vaddr,PAGE_SIZE+32+16);
  //free(source_page_vaddr);

  // This handles wrapping the data into an edge_data_t and storing it
  // in the shared region.
  if( edge_call_setup_wrapped_ret(edge_call, (void*)&p, sizeof(pages))){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }

  return;
}


//------------------------------------------------------------------------------
void get_enclave_content_from_epm_wrapper(void* buffer)
{


  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  void* victim_page_content_ptr=  (void*)call_args;
  //uintptr_t destination_page_to_store_victim_page =(uintptr_t)malloc(PAGE_SIZE+32+16) ;
  uintptr_t destination_page_to_store_victim_page =1 ;

  //memset((void*)destination_page_to_store_victim_page, 0, PAGE_SIZE);
  //memcpy((void*)destination_page_to_store_victim_page,victim_page_content_ptr,PAGE_SIZE+32+16);


  pages p;
  memcpy((void*)&p,victim_page_content_ptr,sizeof(pages));
  //pages_store2.insert(pmap2::value_type(p.address,p));
  p_arr[p.address>>12]=p;
  //printf("[UTM] write request for address 0x%lx and version 0x%lx(pr)\n", p.address,p.ver_num);
  //pages pr=(pages_store2.find(p.address))->second;
  //pages pr=p_arr[(p.address)>>(12)];
  //printf("[UTM](after storing) write request for address 0x%lx and version 0x%lx(pr)\n", pr.address,pr.ver_num);


  // This handles wrapping the data into an edge_data_t and storing it
  // in the shared region.


  if( edge_call_setup_wrapped_ret(edge_call, (void*)&destination_page_to_store_victim_page, sizeof(uintptr_t))){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }

  return;
}
//------------------------------------------------------------------------------
void read_bucket(void* buffer)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  uintptr_t tree_index=   *(uintptr_t*)call_args;//0x3fffefa9b0

  int leaf_start=(int)( 1<<L  ) - 1;
  int leafindex=0;
  if(tree_index>=(uintptr_t)leaf_start)
  {
    leafindex=   tree_index-(uintptr_t)leaf_start;//0x3fffefa9b0
    if(args_user.page_addr_tracing)
    {
      //printf("0x%lx:r,",p.address );
      if(f=='n')
      {
        printf("[UTM]FAULTS ARE TAKING PLACE\n");
        f='y';
      }
      FILE *fptr = fopen(trace_file, "a");
      if (fptr == NULL)
      {
          printf("[UTM] Could not open file in get_host_content_from_utm_wrapper_enc_pfh\n");
          return;
      }
      fprintf(fptr,"%d,",leafindex);
      fclose(fptr);
    }
  }

  if( edge_call_setup_wrapped_ret(edge_call, (void*)(treearray+tree_index), sizeof(Bucket_oram))){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }

  return;
}
//------------------------------------------------------------------------------
void write_buckets(void* buffer)
{

  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */

  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;

  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  uintptr_t tree_index=   *(uintptr_t*)call_args;//0x3fffefa9b0
  memcpy((void*)(&treearray[tree_index]),(void*)( ((uintptr_t*)call_args) +1 ),sizeof(Bucket_oram));
  edge_call->return_data.call_status = CALL_STATUS_OK;
  return;
}
//------------------------------------------------------------------------------
void get_testing_params(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  // This handles wrapping the data into an edge_data_t and storing it
  // in the shared region.
  if( edge_call_setup_wrapped_ret(edge_call, (void*)&args_user, sizeof(enclave_options)) ){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  //printf("[utm] fp= %d\n",args_user.num_free_pages );
  return;
}
//------------------------------------------------------------------------------
void store_content_to_utm_enc_pfh(void* buffer)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  void* victim_page_content_ptr=  (void*)call_args;
  pages_at p;
  memcpy((void*)&p,victim_page_content_ptr,sizeof(pages_at));
  pages_store.insert(pmap::value_type(p.address,p));
  if(args_user.page_addr_tracing)
  {
    if(f=='n')
    {
      printf("[UTM]FAULTS ARE TAKING PLACE\n");
      f='y';
    }
    FILE *fptr = fopen(trace_file, "a");
    if (fptr == NULL)
    {
        printf("[UTM] Could not open file in store_content_to_utm_enc_pfh\n");
        return;
    }
    fprintf(fptr,"0x%lx:w,",p.address);
    fclose(fptr);
  }
  // This handles wrapping the data into an edge_data_t and storing it
  // in the shared region.
  edge_call->return_data.call_status = CALL_STATUS_OK;
  return;
}
//------------------------------------------------------------------------------
void get_host_content_from_utm_wrapper_enc_pfh(void* buffer)
{

  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
   //printf("[UTM] page called start\n" );
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  uintptr_t source_page_vaddr=   *(uintptr_t*)call_args;//0x3fffefa9b0
  pages_at p;
  p= (pages_store.find(source_page_vaddr))->second;
  if(args_user.page_addr_tracing)
  {
    //printf("0x%lx:r,",p.address );
    if(f=='n')
    {
      printf("[UTM]FAULTS ARE TAKING PLACE\n");
      f='y';
    }
    FILE *fptr = fopen(trace_file, "a");
    if (fptr == NULL)
    {
        printf("[UTM] Could not open file in get_host_content_from_utm_wrapper_enc_pfh\n");
        return;
    }
    fprintf(fptr,"0x%lx:r,",p.address);
    fclose(fptr);
  }
  // This handles wrapping the data into an edge_data_t and storing it
  // in the shared region.
  if( edge_call_setup_wrapped_ret(edge_call, (void*)&p, sizeof(pages_at))){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }





  return;
}

//  ------------------------OPAM FUNCTIONS BEGIN------------------------

//------------------------------------------------------------------------------
void opam_write_buckets(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  uintptr_t tree_index=   *(uintptr_t*)call_args;//0x3fffefa9b0
  //Bucket_opam_md buc_md;
  //printf("[UTM] REQUEST FOR index 0x%lx\n", tree_index);
  memcpy((void*)(tree_opam_md+tree_index), (void*)( ((uintptr_t*)call_args) + 1  ),sizeof(Bucket_opam_md));
  //tree_opam_md[tree_index]=buc_md;

  //Bucket_opam buc_d;
  //memcpy((void*)(tree_opam+tree_index), (void*)( call_args+sizeof(uintptr_t)+ sizeof(Bucket_opam_md) ),sizeof(Bucket_opam));// uncomment this


  //tree_opam[tree_index]=buc_d;
  edge_call->return_data.call_status = CALL_STATUS_OK;
  return;
}
//------------------------------------------------------------------------------
void opam_read_bucket_md(void* buffer)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  uintptr_t tree_index=   *(uintptr_t*)call_args;//0x3fffefa9b0

  // This handles wrapping the data into an edge_data_t and storing it
  // in the shared region.
  //printf("[UTM] IN READ BUCKETS\n" );
  if( edge_call_setup_wrapped_ret(edge_call, (void*)(tree_opam_md+tree_index), sizeof(Bucket_opam_md))){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;

}
//------------------------------------------------------------------------------
void opam_read_bucket_d(void* buffer)
{
  /* For now we assume the call struct is at the front of the shared
   * buffer. This will have to change to allow nested calls. */
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  uintptr_t tree_index=   *(uintptr_t*)call_args;//0x3fffefa9b0


  if(args_user.page_addr_tracing)
  {
    if(f=='n')
    {
      printf("[UTM]FAULTS ARE TAKING PLACE\n");
      f='y';
    }
    FILE *fptr = fopen(trace_file, "a");
    if (fptr == NULL)
    {
        printf("[UTM] Could not open file in store_content_to_utm_enc_pfh\n");
        return;
    }
    fprintf(fptr,"0x%lx:r,",tree_opam_md[tree_index].blocks[0].enclav_vaddr);
    fclose(fptr);
  }


  // This handles wrapping the data into an edge_data_t and storing it
  // in the shared region.
  //printf("[UTM] IN READ BUCKETS\n" );
  if( edge_call_setup_wrapped_ret(edge_call, (void*)(tree_opam+tree_index), sizeof(Bucket_opam))){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }

  return;

}

//------------------------------------------------------------------------------
void opam_write_buckets_d(void* buffer)
{

  //printf("[UTM] opam_write_buckets_d entered\n" );
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;

  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  uintptr_t tree_index=   *(uintptr_t*)call_args;//0x3fffefa9b0
  //Bucket_opam buc_d;
  memcpy((void*)(tree_opam+tree_index), (void*)( ((uintptr_t*)call_args) + 1  ),sizeof(Bucket_opam));
  //tree_opam[tree_index]=buc_d;
  edge_call->return_data.call_status = CALL_STATUS_OK;

  if(args_user.page_addr_tracing)
  {
    if(f=='n')
    {
      printf("[UTM]FAULTS ARE TAKING PLACE\n");
      f='y';
    }
    FILE *fptr = fopen(trace_file, "a");
    if (fptr == NULL)
    {
        printf("[UTM] Could not open file in store_content_to_utm_enc_pfh\n");
        return;
    }
    fprintf(fptr,"0x%lx:w,",tree_opam_md[tree_index].blocks[0].enclav_vaddr);
    fclose(fptr);
  }


  //printf("[UTM] Contents during write 0x%lx(ind = %lu) :\n",tree_opam_md[tree_index].blocks[0].enclav_vaddr,tree_index );
  //display_page_contents_arr(tree_opam[tree_index].blocks[0].page);
  //printf("\n" );

  return;
}
//------------------------------------------------------------------------------
void opam_write_buckets_md(void* buffer)
{


  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;

  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  uintptr_t tree_index=   *(uintptr_t*)call_args;//0x3fffefa9b0
  Bucket_opam_md buc_md;
  memcpy((void*)&buc_md, (void*)( ((uintptr_t*)call_args) + 1  ),sizeof(Bucket_opam_md));
  tree_opam_md[tree_index]=buc_md;
  if(args_user.debug_mode)
  {
      //printf("[UTM] opam_write_buckets_md recvd 0x%lx\n" ,tree_opam_md[tree_index].blocks[0].enclav_vaddr);
  }

  tree_opam[tree_index]=tree_opam[buc_md.blocks[0].tree_index];
  tree_opam_md[tree_index].blocks[0].tree_index=tree_index;

  edge_call->return_data.call_status = CALL_STATUS_OK;
  //printf("[UTM] opam_write_buckets_md DONEs\n" );
  if(tree_opam_md[tree_index].blocks[0].enclav_vaddr!=0)
  {
    //printf("[UTM] opam_write_buckets_md recvd 0x%lx(index = %lu)\n" ,tree_opam_md[tree_index].blocks[0].enclav_vaddr,tree_index);
  }
  return;
}
//------------------------------------------------------------------------------

void display_page_contents_arr(char *a)
{
  //return;
  for(int i=0;i<32;i++)
  {
    printf("0x%lx ",a[i] );
  }
}

//----------------------------------RORAM FUNCTIONS BEGIN-----------------------

//------------------------------------------------------------------------------
void roram_write_bucket_init(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;

  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  uintptr_t tree_index=   *(uintptr_t*)call_args;
  Bucket_roram buc_d;
  memcpy((void*)(tree_roram_d+tree_index), (void*)( call_args+sizeof(uintptr_t)),sizeof(Bucket_roram));
  //tree_roram_d[tree_index]=buc_d;

  if(args_user.page_addr_tracing)
  {
    FILE *fptr = fopen(trace_file, "a");
    if (fptr == NULL)
    {
        printf("[UTM] Could not open file in get_host_content_from_utm_wrapper_enc_pfh\n");
        return;
    }
    for(int i=0;i<RORAM_BUCKET_SIZE;i++)
    {
      fprintf(fptr,"0x%lx:w,",tree_roram_d[tree_index].blocks[i].address);
    }
    fclose(fptr);
  }



  edge_call->return_data.call_status = CALL_STATUS_OK;
  return;
}
//------------------------------------------------------------------------------
void roram_read_block(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;

  uintptr_t call_args;
  unsigned long ret_val;
  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }
  uintptr_t tree_index=   *(uintptr_t*)call_args;
  uintptr_t offset=   *(uintptr_t*)(call_args+sizeof(uintptr_t));


  if(args_user.page_addr_tracing)
  {
    FILE *fptr = fopen(trace_file, "a");
    if (fptr == NULL)
    {
        printf("[UTM] Could not open file in get_host_content_from_utm_wrapper_enc_pfh\n");
        return;
    }
    fprintf(fptr,"0x%lx:r,",tree_roram_d[tree_index].blocks[offset].address);
    fclose(fptr);
  }





  if( edge_call_setup_wrapped_ret(edge_call, (void*)&(tree_roram_d[tree_index].blocks[offset]), sizeof(Block_roram))){
    edge_call->return_data.call_status = CALL_STATUS_BAD_PTR;
  }
  else{
    edge_call->return_data.call_status = CALL_STATUS_OK;
  }
  return;
}


//------------------------------------------------------------------------------

void full_trace(void* buffer)
{
  struct edge_call_t* edge_call = (struct edge_call_t*)buffer;
  uintptr_t call_args;
  unsigned long ret_val;

  if(edge_call_args_ptr(edge_call, &call_args) != 0){
    edge_call->return_data.call_status = CALL_STATUS_BAD_OFFSET;
    return;
  }

  uintptr_t total=   *(uintptr_t*)call_args;//0x3fffefa9b0

  uintptr_t *vpn=(  ((uintptr_t*)call_args)+1)     ;

  FILE *fptr = fopen(trace_file, "a");
  if (fptr == NULL)
  {
      printf("[UTM] Could not open file in get_host_content_from_utm_wrapper_enc_pfh\n");
      return;
  }
  //printf("[UTM] Number of pages got %lu   ",total );
  for(int i=0;i<total;i++)
  {
    fprintf(fptr,"%lu,",vpn[i]);
  }
  fclose(fptr);
}
